// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using Microsoft.DotNet.Build.Tasks;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Microsoft.DotNet.GenFacades
{
    internal class SourceGenerator
    {
        private readonly IReadOnlyDictionary<string, string> _seedTypePreferences;
        private readonly IEnumerable<string> _referenceTypes;
        private readonly IReadOnlyDictionary<string, IList<string>> _seedTypes;
        private readonly string _outputSourcePath;
        private readonly HashSet<string> _ignoreMissingTypesList = new HashSet<string>();
        private readonly ILog _logger;

        public SourceGenerator(
            IEnumerable<string> referenceTypes,
            IReadOnlyDictionary<string, IList<string>> seedTypes,
            IReadOnlyDictionary<string, string> seedTypePreferences,
            string outputSourcePath,
            string[] ignoreMissingTypesList,
            ILog logger
            )
        {
            _referenceTypes = referenceTypes;
            _seedTypes = seedTypes;
            _seedTypePreferences = seedTypePreferences;
            _outputSourcePath = outputSourcePath;
            _logger = logger;
            _ignoreMissingTypesList = ignoreMissingTypesList != null 
                                        ? new HashSet<string>(ignoreMissingTypesList)
                                        : new HashSet<string>();
        }

        public bool GenerateSource(
            IEnumerable<string> compileFiles,
            IEnumerable<string> constants,
            bool ignoreMissingTypes)
        {
            var typesAndAliases = new List<(string TypeName, string Alias)>();
            var externAliases = new List<string>();
            bool result = GetTypes(compileFiles, constants, ignoreMissingTypes, typesAndAliases, externAliases);

            if (result)
            {
                StringBuilder sb = new StringBuilder();

                if (_outputSourcePath.EndsWith(".vb", StringComparison.OrdinalIgnoreCase))
                {
                    sb.AppendLine("' <auto-generated/>"); // Adding this because the following code is autogenerated.
                    foreach (var (type, _) in typesAndAliases)
                    {
                        sb.AppendLine(GetTypeForwardsToVisualBasicString(type));
                    }
                }
                else
                {
                    sb.AppendLine("// <auto-generated/>"); // Adding this because the following code is autogenerated.
                    foreach (string alias in externAliases)
                    {
                        sb.AppendLine(string.Format("extern alias {0};", alias));
                    }
                    sb.AppendLine("#pragma warning disable CS0618"); // Adding this to avoid warnings while adding typeforwards for obsolete types.
                    foreach (var (type, alias) in typesAndAliases)
                    {
                        sb.AppendLine(GetTypeForwardsToCSharpString(type, alias));
                    }
                    sb.AppendLine("#pragma warning restore CS0618");
                }

                File.WriteAllText(_outputSourcePath, sb.ToString());
            }

            return result;
        }

        private bool GetTypes(
            IEnumerable<string> compileFiles,
            IEnumerable<string> constants,
            bool ignoreMissingTypes,
            List<(string TypeName, string Alias)> typesAndAliases,
            List<string> externAliases)
        {
            bool result = true;

            HashSet<string> existingTypes = compileFiles != null ? TypeParser.GetAllPublicTypes(compileFiles, constants) : null;
            IEnumerable<string> typesToForward = compileFiles == null ? _referenceTypes : _referenceTypes.Where(id => !existingTypes.Contains(id));

            foreach (string type in typesToForward.OrderBy(s => s))
            {
                IList<string> seedTypes;
                if (!_seedTypes.TryGetValue(type, out seedTypes))
                {
                    if (!ignoreMissingTypes && !_ignoreMissingTypesList.Contains(type))
                    {
                        result = false;
                        _logger.LogError("Did not find type '{0}' in any of the seed assemblies.", type);
                    }
                    continue;
                }

                string alias = "";

                if (_seedTypePreferences.Keys.Contains(type))
                {
                    alias = _seedTypePreferences[type];
                    if (!externAliases.Contains(alias))
                        externAliases.Add(alias);
                }
                else if (seedTypes.Count > 1)
                {
                    _logger.LogError("The type '{0}' is defined in multiple seed assemblies. The multiple assemblies are {1}. If this is intentional, specify the alias for this type and project reference", type, string.Join(", ", seedTypes));
                    result = false;
                    continue;
                }

                typesAndAliases.Add((type, alias));
            }

            externAliases.Sort();

            return result;
        }

        private static string GetTypeForwardsToCSharpString(string typeName, string alias = "")
        {
            if (!string.IsNullOrEmpty(alias))
                alias += "::";

            return string.Format($"[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof({alias}{TransformGenericType(typeName)}))]");

            // Typename`3 gets transformed into Typename<,,>
            static string TransformGenericType(string typeName)
            {
                int splitIndex = typeName.LastIndexOf('`');

                if (splitIndex == -1)
                    return typeName;

                StringBuilder sb = new StringBuilder();
                sb.Append(typeName.Substring(0, splitIndex));
                sb.Append('<');
                sb.Append(',', int.Parse(typeName.Substring(splitIndex + 1)) - 1);
                sb.Append('>');
                return sb.ToString();
            }
        }

        private static string GetTypeForwardsToVisualBasicString(string typeName)
        {
            return string.Format($"<Assembly: System.Runtime.CompilerServices.TypeForwardedTo(GetType({TransformGenericType(typeName)}))>");

            // Typename`3 gets transformed into Typename(Of ,,)
            static string TransformGenericType(string typeName)
            {
                int splitIndex = typeName.LastIndexOf('`');

                if (splitIndex == -1)
                    return typeName;

                StringBuilder sb = new StringBuilder();
                sb.Append(typeName.Substring(0, splitIndex));
                sb.Append("(Of ");
                sb.Append(',', int.Parse(typeName.Substring(splitIndex + 1)) - 1);
                sb.Append(')');
                return sb.ToString();
            }
        }
    }
}
